<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Groper by ipartola</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/ipartola/groper">Fork On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/ipartola/groper/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/ipartola/groper/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Groper</h1>
          <p>Python library for parsing config files and command line arguments</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/ipartola">ipartola</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/#!/michigangraham">mattgraham</a></span>
        </div>

        <h2>groper: simple Python command line and config file options</h2>

<p>Python programs that run from the command line often times contain code that looks like this:</p>

<pre><code>DEFAULT_PORT = 8080
def main():
    if len(sys.argv) &gt; 2 and sys.argv[1] == '-p':
        port = int(sys.argv[2])
    else:
        port = DEFAULT_PORT
</code></pre>

<p>While technically correct, this code does not scale well. The next evolution of this code would use either getopt, argparse or optparse to help abstract parsing command line options. However, at some point the number of options would grow so large that a configuration file might be warranted and ConfigParser is introduced.</p>

<p>However, the complexity of the code grows as this happens. To use (argparse|optparse|getopt) + ConfigParser effectively and correctly the program needs to:</p>

<ul>
<li>  Parse the command line args, and figure out where the configuration file resides</li>
<li>  Read the configuration file and combine it with the command line args (the command line args take precidence)</li>
<li>  If not all required command line args are specified, print program usage and exit.</li>
<li>  The wrapper around ConfigPraser needs to provide a simple way to access the data</li>
<li>  Some values need to have defaults, which should be used if the config file and the command line args do not specify one</li>
</ul><p>Implementing this logic in each Python program is redundant. However, it seems that most programs do it this way. groper provides a simple unified interface for reading command line args, configuration files, setting defaults, printing program usage and even generating sample configuration files. Here is an example of its usage:</p>

<pre><code>from groper import define_opt, init_options, options

define_opt('server', 'host', type=unicode, cmd_name='host', cmd_short_name='h', default='localhost')
define_opt('server', 'port', type=int, cmd_name='port', cmd_short_name='p', default=8080)
define_opt('server', 'daemon', type=bool, cmd_name='daemon', cmd_short_name='d')

# init_options() will automatically read this file. If you don't use a config file, simply comment this out
#define_opt('meta', 'config', type=unicode, cmd_only=True, cmd_name='config', cmd_short_name='c', is_config_file=True)

# If specified: program usage will be printed and returned
# The cmd_group param means that when the usage is printed, this option will be specified in its own group
define_opt('meta', 'help', type=bool, cmd_only=True, cmd_name='help', cmd_short_name='H', is_help=True, cmd_group='help')

def main():
    init_options()
    print options.server.host
    print options.server.port
    print options.server.daemon

if __name__ == '__main__':
    main()
</code></pre>

<p>That's it. You can use the options object from any module in which you import it to get access to the program settings. The <em>default</em> argument to the define_opt() function also provides a great feature: you can now specify all your constants as configurable options that can be read from the configuration file.</p>

<p>As if that wasn't enough, you can even generate sample configuration files:</p>

<pre><code>from groper import define_opt, init_options, options

define_opt('server', 'host', type=unicode, cmd_name='host', cmd_short_name='h', default='localhost')
define_opt('server', 'port', type=int, cmd_name='port', cmd_short_name='p', default=8080)
define_opt('server', 'daemon', type=bool, cmd_name='daemon', cmd_short_name='d')

print generate_sample_config()
</code></pre>

<p>Hopefully you will find groper useful. It can be installed via PyPi:</p>

<pre><code>$ pip install groper
</code></pre>

<p>groper is licensed under the MIT license and is Copyright (c) 2011-2012 Igor Partola</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
  </body>
</html>